const { unix } = require("moment");
var moment = require("moment");
const models = require("./models");
const axios = require("axios");

exports.handler = function (event, context) {
  console.log("hello world");
  testin(context);
};

// select "orgId", "accessPointId", json_agg(json_build_object('direction',"accessPointDirection", "eventTime" ,"eventTime", 'accessPointId' ,"accessPointId", 'orgId', "orgId" ) order by de."eventTime" ) from door_events de
// group by "orgId", "accessPointId"

async function sendAlarm(doorObj) {
  var msgFormat = {
    msgType: "door_exception",
    msgVersion: 1,
    data: [
      {
        id: doorObj.id,
        orgId: doorObj.orgId,
        createdAt: doorObj.doorEventCreatedAt,
        eventInfo: {
          eventType: "door_ajar",
          eventTime: doorObj.eventTime,
        },
        accessPoint: {
          id: doorObj.accessPointId,
          name: doorObj.accessPointName,
          accessPointDirection: doorObj.direction,
          siteId: doorObj.siteId,
          siteName: doorObj.siteName,
          siteLocation: doorObj.siteLocation,
        },
      },
    ],
  };

  console.log(msgFormat);
  let res = await sendToService(
    msgFormat,
    "https://gxliivh0rl.execute-api.ap-south-1.amazonaws.com/dev/integrationService/events",
    "/dev/integrationService/events",
    { "x-api-key": "0cHPPsfdsfB8l234lkfsdlfdsSYfjksd6Qd41tYh" },
    "POST"
  );
}

async function deleteEntries(deleteArray) {
  var [door_events, e] = await models.sequelize.query(
    `DELETE from door_events where id IN (${deleteArray.join()})`
  );
}

async function sendToService(postData, webhook, path, headers, method) {
  console.log("reaching here");
  if (method && method.toUpperCase() == "PATCH") {
    return new Promise((resolve, reject) => {
      let response = axios
        .patch(`${webhook}`, postData, { headers: headers })
        .then(function (res) {
          // return res.data.access_token;
          resolve(res);
        })
        .catch(function (error) {
          // console.log(error.response.data);
          reject(error);
        });

      return response;
    });
  } else if (method && method.toUpperCase() == "PUT") {
    return new Promise((resolve, reject) => {
      let response = axios
        .put(`${webhook}`, postData, { headers: headers })
        .then(function (res) {
          // return res.data.access_token;
          resolve(res);
        })
        .catch(function (error) {
          // console.log(error.response.data);
          reject(error);
        });

      return response;
    });
  } else {
    return new Promise((resolve, reject) => {
      let response = axios
        .post(`${webhook}`, postData, { headers: headers })
        .then(function (res) {
          // return res.data.access_token;
          console.log(res);
          resolve(res);
        })
        .catch(function (error) {
          // console.log(error.response.data);
          console.log(error);
          reject(error);
        });

      console.log("response");
      console.log(response);
      return response;
    });
  }
}

async function testin(context) {
  var [door_events, e] = await models.sequelize.query(
    `select "orgId", "accessPointId", 
    json_agg(json_build_object('id',id,'doorEventCreatedAt',"doorEventCreatedAt",'direction',"accessPointDirection", 'eventType' ,"eventType",'eventTime' ,"eventTime", 'accessPointId' ,"accessPointId", 'accessPointName', "acessPointName" ,'orgId', "orgId", 'siteId', "siteId", 'siteName', "siteName", 'siteLocation' ,"siteLocation") order by de."eventTime" ) as "doorObj" from door_events de 
    group by "orgId", "accessPointId" 
    `
  );

  console.log(door_events.length);
  console.log(door_events);

  if (door_events.length <= 0) {
    return;
  }

  var deleteArray = [];
  for (var i = 0; i < door_events.length; i++) {
    var entryTime = null,
      exitTime = null;
    var entryid, exitId;
    console.log(door_events[i].doorObj);
    for (var j = 0; j < door_events[i].doorObj.length; j++) {
      var a = door_events[i].doorObj[j];
      var p, q;
      switch (a.eventType) {
        case "door_open":
          // console.log("entry");
          entryTime = a.eventTime;
          entryid = a.id;
          break;
        case "door_close":
          if (!entryTime) {
            exitId = a.id;
            var exitTimeUnix = moment.unix(exitTime);
            var currentTimeUnix = moment.unix(moment().unix());
            console.log(exitTimeUnix);
            console.log(currentTimeUnix);
            if (currentTimeUnix.diff(exitTimeUnix, "minutes") > 1) {
              sendAlarm(a);
            }
            deleteArray.push(exitId);
          } else {
            exitTime = a.eventTime;
            exitId = a.id;
            p = moment.unix(entryTime);
            q = moment.unix(exitTime);
            console.log("orgid");
            console.log(door_events[i].orgId);
            console.log("accessPointId");
            console.log(door_events[i].accessPointId);
            console.log("time");
            console.log(q.diff(p, "minutes"));
            if (q.diff(p, "minutes") > 1) {
              sendAlarm(a);
            }
            deleteArray.push(entryid);
            deleteArray.push(exitId);
          }
          entryTime = null;
          exitTime = null;
          // code block
          break;
        default:
        // code block
      }
    }
    if (exitId) {
      console.log(deleteArray);
      deleteEntries(deleteArray);
      deleteArray = [];
    }
  }
  // context.succeed("success");
}
